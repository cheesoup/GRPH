<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="/GRPH/assets/css/style.css"/>
    <link rel="alternate" type="application/atom+xml" title="thesis? idk?" href="/GRPH/feed.xml"/>
    <link rel="shortcut icon" type="image/png" href="/GRPH/icon.ico"/>
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Oscillator Design Part I - Anti-aliasing | thesis? idk?</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Oscillator Design Part I - Anti-aliasing" />
<meta name="author" content="Chris Carin" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I mentioned in a previous post how naively generating waveforms digitally can result in unwanted distortion. The distortion is caused by a phenomenon known as fold-over aliasing and is often the reason why older implementations of digital oscillators sound ‘cheap’. To handle fold-over, I’ve incorporated two algorithms within my oscillators which have proven effective when working in PureData. The first is a well-known algorithm known as PolyBLEP. The second is a bit of an obscure one dubbed ‘Frequency Dithering’." />
<meta property="og:description" content="I mentioned in a previous post how naively generating waveforms digitally can result in unwanted distortion. The distortion is caused by a phenomenon known as fold-over aliasing and is often the reason why older implementations of digital oscillators sound ‘cheap’. To handle fold-over, I’ve incorporated two algorithms within my oscillators which have proven effective when working in PureData. The first is a well-known algorithm known as PolyBLEP. The second is a bit of an obscure one dubbed ‘Frequency Dithering’." />
<link rel="canonical" href="http://0.0.0.0:4000/GRPH/audio/2021/12/06/oscillator-design-antialiasing.html" />
<meta property="og:url" content="http://0.0.0.0:4000/GRPH/audio/2021/12/06/oscillator-design-antialiasing.html" />
<meta property="og:site_name" content="thesis? idk?" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-12-06T00:00:00-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Oscillator Design Part I - Anti-aliasing" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"Chris Carin"},"@type":"BlogPosting","headline":"Oscillator Design Part I - Anti-aliasing","dateModified":"2021-12-06T00:00:00-05:00","datePublished":"2021-12-06T00:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://0.0.0.0:4000/GRPH/audio/2021/12/06/oscillator-design-antialiasing.html"},"description":"I mentioned in a previous post how naively generating waveforms digitally can result in unwanted distortion. The distortion is caused by a phenomenon known as fold-over aliasing and is often the reason why older implementations of digital oscillators sound ‘cheap’. To handle fold-over, I’ve incorporated two algorithms within my oscillators which have proven effective when working in PureData. The first is a well-known algorithm known as PolyBLEP. The second is a bit of an obscure one dubbed ‘Frequency Dithering’.","url":"http://0.0.0.0:4000/GRPH/audio/2021/12/06/oscillator-design-antialiasing.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>
  <body>
    <header>  <!-- HEADER START -->
      <a href="/GRPH/"><img src="/GRPH/assets/images/jam_crow.gif" alt="jam_crow.gif" width="128" height="68"/></a>
      <nav>   <!-- MENU START -->
        <ul>
          
          <li><a href="/GRPH/about">about</a></li>
          
          <li><a href="/GRPH/audio">audio</a></li>
          
          <li><a href="/GRPH/website">web</a></li>
          
          <li><a href="/GRPH/misc">misc</a></li>
          
          <li><a href="/GRPH/tags">tags</a></li>
          
        </ul>
      </nav>   <!-- MENU END -->
    </header>  <!-- HEADER END -->
    <main>     <!-- CONTENT START -->
      


<header class="heading">
  <h1>Oscillator Design Part I - Anti-aliasing</h1>
  <div>
    <small>
      Category: <a href="">Audio</a>
    </small>
    <small>
      Tags:
      
        <a href="/GRPH/tags#programming">Programming</a>
      
        <a href="/GRPH/tags#oscillators">Oscillators</a>
      
        <a href="/GRPH/tags#bela">Bela</a>
      
    </small>
  </div>
  <div>
    <small>
      Mon, Dec 06, 21
    </small>
    <small>
      
      Length:
      
        5 mins
      
    </small>
  </div>
</header>

<p>I mentioned in a previous post how naively generating waveforms digitally can result in unwanted distortion. The distortion is caused by a phenomenon known as fold-over aliasing and is often the reason why older implementations of digital oscillators sound ‘cheap’. To handle fold-over, I’ve incorporated two algorithms within my oscillators which have proven effective when working in PureData. The first is a well-known algorithm known as PolyBLEP. The second is a bit of an
obscure one dubbed ‘Frequency Dithering’.</p>

<h2 id="polybleps">PolyBLEPs</h2>

<p>The PolyBLEP algorithm is part of a family of BLIT/BLEP algorithms. The idea behind BLITs/BLEPs is to smooth out discontinuities using bandlimited functions. The PolyBLEP in particular is named so due to its use of a <a href="https://www.scribd.com/document/85351585/Computation-Ally-Effective-Methods-of-Sound-Synthesis">polynomial bandlimited step function</a> to achieve this. All this really means is two things: 1) it makes use of one of those math problems from high school that you can solve using the quadratic formula, 2) this math problem is limited in the frequency band it can produce.</p>

<p>My implementation is primarily based on a blog post by <a href="http://www.martin-finke.de/blog/articles/audio-plugins-018-polyblep-oscillator/">Martin Finke</a> which in turn is based on a <a href="https://www.kvraudio.com/forum/viewtopic.php?t=375517">KVRforums thread</a>. As mentioned above, PolyBLEPs make use of a polynomial to smooth out discontinuities within a periodic waveform. To make use of polyBLEPs, we first need to synthesize a waveform with discontinuities. The simplest way to do this is with a sawtooth wave.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">delta</span> <span class="o">=</span> <span class="n">frequency</span> <span class="o">/</span> <span class="n">sample_rate</span><span class="p">;</span>
<span class="n">phase</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">current_sample_count</span><span class="p">;</span>
<span class="n">sample</span> <span class="o">=</span> <span class="mi">2</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>From here, we check if the phase is within range of <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">delta</code> or <code class="language-plaintext highlighter-rouge">1 - delta</code> to <code class="language-plaintext highlighter-rouge">delta</code>. If it is, we splice in the function <code class="language-plaintext highlighter-rouge">phase*phase + 2*phase + 1</code>. Otherwise, we don’t do anything. Below is how this function is implemented in the original KVR thread. <a href="https://github.com/cheesoup/CheeseVA/blob/b403b30badaec110a6298c1580ad2d2e85ccac06/BasicWaves.cpp#L167">My implementation</a> isn’t much different.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// 0 &lt;= t &lt; 1</span>
<span class="k">if</span> <span class="p">(</span><span class="n">phase</span> <span class="o">&lt;</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">phase</span> <span class="o">/=</span> <span class="n">delta</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">phase</span><span class="o">+</span><span class="n">phase</span> <span class="o">-</span> <span class="n">phase</span><span class="o">*</span><span class="n">phase</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// -1 &lt; t &lt; 0</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">phase</span> <span class="o">&gt;</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">phase</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">/</span> <span class="n">delta</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">phase</span><span class="o">*</span><span class="n">phase</span> <span class="o">+</span> <span class="n">phase</span><span class="o">+</span><span class="n">phase</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 0 otherwise</span>
<span class="k">else</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="mf">0.</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h2 id="frequency-dithering">Frequency Dithering</h2>

<p>The original implementation of frequency dithering was put together by <a href="https://www.youtube.com/channel/UC84u8v2FyqmXjSxYh1d7PRQ">Scott ‘Acriel’ Nordlund</a> in PureData. Other than on the <a href="https://forum.pdpatchrepo.info/topic/6759/new-anti-aliasing-and-phase-distortion-abstractions">Pd forums</a>, I’ve never actually seen this algorithm written about. The idea behind it is to fix frequencies to integer ratios to sample rate. This by itself has the effect of causing a frequency components above Nyquist to re-align with the harmonic series (<code class="language-plaintext highlighter-rouge">base_freq * 2, * 4, * 8, * 16, etc</code>) at the cost of tuning error. To fix tuning, we generate an average frequency by calculating the two closest frequencies allowed given the above restrictions and rapidly modulate between them.</p>

<p>Below is my implementation of the frequency dithering in C++. Prior to calculating frequencies, we check if the target frequency is 0. If it is, we skip the whole process and output 0. Otherwise, the first of the pair of frequencies are found by dividing the sample rate by the incoming frequency and flooring it, and then dividing the sample rate by the result. The second frequency is found the same way except prior to dividing the sample rate, we add one to the floored ratio. To decide which of the two frequencies to output, we calculated the distance of both frequencies from the target and then performed a weighted dice roll to choose.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">f</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Find the two closest integer ratios for samplerate/frequency</span>
  <span class="kt">int</span> <span class="n">ratio</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="n">SR</span> <span class="o">/</span> <span class="o">*</span><span class="n">f</span><span class="p">);</span>
  <span class="kt">float</span> <span class="n">f_d0</span> <span class="o">=</span> <span class="o">*</span><span class="n">SR</span> <span class="o">/</span> <span class="p">(</span><span class="n">ratio</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="kt">float</span> <span class="n">f_d1</span> <span class="o">=</span> <span class="o">*</span><span class="n">SR</span> <span class="o">/</span> <span class="n">ratio</span><span class="p">;</span>
  <span class="c1">// Dither between the two using a weighted random roll</span>
  <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">f</span> <span class="o">-</span> <span class="n">f_d0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">f_d1</span> <span class="o">-</span> <span class="n">f_d0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">fmath</span><span class="o">::</span><span class="n">fast_rand</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">seed</span><span class="p">)))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">f_d0</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">f_d1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c1">// If the given frequency is 0, return 0;</span>
  <span class="k">return</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h2 id="conclusion">Conclusion</h2>

<p>So yeah, that’s about it. I’m a little tired, so I’ll probably put up some examples of how a sawtooth sweep of how these oscillators sound another time. For my next post I plan to go over arbitrary wavemorphing again. My original version of that post kinda sucked. Until then, GOOD NIGHT!</p>


<!-- Grab previous and next post from category -->
<!-- https://talk.jekyllrb.com/t/how-to-link-to-next-and-previous-posts-for-same-blog-category/629 -->






<footer class="pagination">
  <nav>
    <h3>Pagination</h3>
    <ul>
      <!-- Page Up -->
      <li>
        <a class="up" href="/GRPH/Audio">
          Back to Audio
        </a>
      </li>
      <!-- Prev post -->
      <li>
        <a class="next" href="/GRPH/audio/2021/12/05/CheeseVA-Demo-Footage.html">
          CheeseVA Demo Footage!
        </a>
      </li>
      <!-- Next post -->
      <li>
        <a class="prev" href="/GRPH/audio/2021/12/06/oscillator-design-antialiasing.html">
          Oscillator Design Part I - Anti-aliasing
        </a>
      </li>
    </ul>
  </nav>
  <nav>
    <h3>Related Posts</h3>
    
    
    <ul>
      <li>
        <a href="/GRPH/audio/2021/10/14/fft_grainspec.html">
          FFT Spectral Granulator
        </a>
      </li>
    </ul>
    
    <ul>
      <li>
        <a href="/GRPH/audio/2021/11/29/sample-rates-and-harmonics.html">
          Sampling Rates & Harmonics
        </a>
      </li>
    </ul>
    
    <ul>
      <li>
        <a href="/GRPH/audio/2021/11/16/why-im-making-a-synth.html">
          Thoughts on why I'm making a synthesizer
        </a>
      </li>
    </ul>
    
  </nav>
</footer>

    </main>    <!-- CONTENT END -->
    <footer>   <!-- FOOTER START -->
      <ul>
        <li><a href="/GRPH/feed.xml">RSS Feed</a></li>
        <li>
          <a href="https://www.gnu.org/licenses/copyleft.en.html">(C)</a>
           2021-2022
          <a href="mailto:chr.carin(a)gmail.com">Chris Carin</a>
        </li>
        <li><a href="https://html5.validator.nu/?doc=http://0.0.0.0:4000/GRPH/audio/2021/12/06/oscillator-design-antialiasing.html">This document is valid HTML5</a></li>
        <li><a href="#">Back to Top</a></li>
      </ul>
    </footer>   <!-- FOOTER END -->
  </body>
</html>
